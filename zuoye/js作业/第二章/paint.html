<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>画图</title>
  <style>
    canvas {
      border: 2px solid #f0f;
      display: block;
      margin: auto;
    }
  </style>
</head>
<body>
  <canvas width="500" height="400"></canvas>
</body>
<script>
  var canvas = document.querySelector('canvas')
  canvas.style.imageRendering = 'pixelated' //放大时的插帧方式：不插帧，直接放大像素
  var ctx = canvas.getContext('2d')

  function dot(x, y, color = 'black') {
    x = Math.round(x)
    y = Math.round(y)
    ctx.fillStyle = color
    ctx.fillRect(x, y, 1, 1)
  }
  /**
   * YOUR TASK
      * 在 坐标 (42, 42) 画出一个点
      * 画一条实线
      * 画一条一个实点一个空点的虚线
      * 画一条两个实点两个空点的虚线
      * 画一条三个实点两个空点的虚线
      * 画一条45度的斜线
      * 画一条30度的斜线（与x轴或y轴的夹角呈30度）
      * 画一条跨越画布左上角和右下角的对角线
      * 画一个空心矩形
      * 画一个实心矩形
      * 画两个个空心的圆，居中：
        * 一个半径为50像素
        * 一个半径为200像素
      * 画一个实心的圆，半径至少为100像素
      * 画一个【大小合适】的sin(x)的图像

      * 画出rgb色彩空间的某一面（尺寸要大于100x100）
        如果做出上一题后，尝试将其每个点的坐标乘以一个矩阵（如(2,0,0,2)或(1,0.27得到新的位置，即绘制出被线性变幻后的色彩空间某一面
        可以考虑如下几种矩阵：
           2 0
           0 2
           ------
           1  0.27
           0  1
           ------
           0.5    0.87
           -0.87  0.5

   */
</script>
<script>
  // 不可更改上面的代码
  // 你的代码写在这里
  // YOUR CODE GOES BELOW
  // 在 坐标 (42, 42) 画出一个点
  dot(42, 42, color = 'black')

  // 画一条实线
  var x = 1
  var y = 1
  for (var i = 0; i < 40; i++) {
    y = y + 1
    dot (x, y, color = 'black')
  }

  // 画一条一个实点一个空点的虚线
  var x = 5
  var y = 5
  for (var i = 0; i < 40; i++) {
    y = y + 2
    dot (x, y, color = 'black')
  }

  // 画一条两个实点两个空点的虚线
  var x = 10
  var y = 10
  for (var i = 0; i < 40; i++) {
    y = y + 1
    dot (x, y, color = 'black')
    y = y + 1
    dot (x, y, color = 'black')
    y = y + 2
  }

  // 画一条三个实点两个空点的虚线
  var x = 15
  var y = 15
  for (var i = 0; i < 40; i++) {
    for (var a = 0; a < 3; a++) {
      y = y + 1
      dot (x, y, color = 'black')
    }
    y = y + 2
  }

  // 画一条45度的斜线
  var x = 0
  var y = 0
  for (var i = 0; i < 500; i++) {
    x = x + 1
    dot(x, x, color = 'black')
  }

  // 画一条30度的斜线（与x轴或y轴的夹角呈30度）
  var x = 0
  var y = 0
  var k = Math.sqrt(3) / 3
  for (var i = 0; i < 500; i++) {
    x = x + 1
    dot (x, k * x, color='black')
  }

  // 画一条跨越画布左上角和右下角的对角线
  var x = 0
  var y = 0
  for (var i = 0; i < 500; i++) {
    x = x + 1
    dot(x, 4 / 5 * x, color = 'black')
  }

// 画一个空心矩形
  var 竖线x = 100
  var 竖线y = 100
  dot(竖线x, 竖线y, color ='red')
  var 水平线x = 100
  var 水平线y = 100
  dot(水平线x, 水平线y, color ='red')
  for (var i = 0; i < 100; i++) {
    竖线y = 竖线y + 1
    dot(竖线x, 竖线y, color = 'red')
    dot(竖线x + 100, 竖线y, color = 'red')
    水平线x = 水平线x + 1
    dot(水平线x, 水平线y, color = 'greed')
    dot(水平线x, 水平线y + 100, color = 'greed')
  }

  // 画一个实心矩形
/* 画出rgb色彩空间的某一面（尺寸要大于100x100）
  如果做出上一题后，尝试将其每个点的坐标乘以一个矩阵（如(2,0,0,2)或(1,0.27得到新的位置，即绘制出被线性变幻后的色彩空间某一面
  可以考虑如下几种矩阵：
      2 0
      0 2
      ------
      1  0.27
      0  1
      ------
      0.5    0.87
      -0.87  0.5 */

/*   var x = 50
  var y = 50
  for (var i = 0; i < 40; i++) {
    y = y + 1 //横线向下平移
    x = 50 //初始化x值
    for (var j = 0; j < 100; j++) { //画横线
      x = x + 1
      dot(x, y, color = 'pink')
    }
  } */

  function rgb(a,b,c) {
    result = 'rgb('
    + a
    + ','
    + b
    + ','
    + c
    return result
  }
  for (var y = 0; y <= 100; y++) {
    for (var x = 0; x <= 100; x++) {
      a = x / 100 * 256
      b = y / 100 * 256
      color = 'rgb(' + a + ',' + b + ',' + '1)'
      color = `rgb(${x}, ${y}, 255)`   //模板字符串
      dot(x + 200, y + 200, color)

      var x1 = 0.5 * x - 0.87 * y
      var y1 = 0.87 * x + 0.5 * y
      dot(x1 + 200, y1, color)
    }
  }

/*   画两个个空心的圆，居中：
        一个半径为50像素
        一个半径为200像素 */
  var PI = Math.PI
  var r = 50
  var R = 100
  for (i = 0; i <= 360; i++) {
    var x = 300
    var y = 300
    var X = 300
    var Y = 300
    x += r * Math.cos(2 * PI / 360 * i)
    y += r * Math.sin(2 * PI / 360 * i)
    dot(x, y, color = 'black')

    X += R * Math.cos(2 * PI / 360 * i)
    Y += R * Math.sin(2 * PI / 360 * i)
    dot(X, Y, color = 'black')
  }

  // 画一个实心的圆，半径至少为100像素
  for (var r = 0; r <= 100; r += 1) {
    for (i = 0; i <= 360; i++) {
      var x = 400
      var y = 100
      x += r * Math.cos(2 * PI / 360 * i)
      y += r * Math.sin(2 * PI / 360 * i)
      dot(x, y, color = 'black')
    }
  }

  // 画一个【大小合适】的sin(x)的图像
  for (var x = 100; x < 1000; x++) {
    let y = 150 + 70 * Math.sin(x / 70)
    dot(x, y, 'green')
  }
</script>
</html>
